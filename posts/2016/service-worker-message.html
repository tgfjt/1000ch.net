<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>メッセージングによるService Workerのコントロール - 1000ch.net</title>

<link rel="icon" href="/favicon.png">
<link rel="shortcut icon" href="/favicon.png">
<link rel="shortcut icon" href="/favicon.svg" type="image/svg+xml" sizes="any">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,700">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto Mono:400,700">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/github.min.css">
<link rel="stylesheet" href="/css/app.min.css">
<link rel="alternate" href="/rss.xml" title="1000ch.net" type="application/rss+xml">

<meta name="author" content="Shogo Sensui">
<meta name="copyright" content="Copyright (c) Shogo Sensui; Licensed under Creative Commons Attribution-Noncommercial-Share Japan">


  
    <meta name="description" content="メッセージングによるService Workerのコントロール Service Workerでハンドルするリソースは、Service Workerのスクリプトに静的に記述しているケースが多い。Service Workerでやっているアレコレをメッセージングで動的にできないか試行錯誤したログ。 よくある?キャッシュパターン チュートリアル等でもよく見かける、Service Workerのインストール時に指定のリソースをキャッシュしているパターン。 const CACHE_KEY = &#39;cache-key&#39;; const CACHE_LIST = [ &#39;index.html&#39;, &#39;app.js&#39;, &#39;app.css&#39; ]; self.addEventListener(&#39;install&#39;, e =&gt; { // CACHE_KEYをキーにとるCacheオブジェクトを開いて // CACHE_LISTをキャッシュするPromise let promise = caches.open(CACHE_KEY) .then(cache =&gt; cache.addAll(CACHE_LIST)) .catch(error =&gt; console.log(error)); e.waitUntil(promise); }); 小さい用途であれば、これで何ら問題はない気はする。開発規模が大きくなってくるとリソースの増加やらで人力でメンテナンスするのが辛くなってくる。 GoogleChrome/sw-precacheはService Workerのスクリプトを書き出すツールで、キャッシュしたいパスのパターン指定などが可能。これでひとまず人力で管理していくリスクは低減できるが、細かい処理を書くには不向き。なので、Service Workerの処理内容を自由に書く余地を残しつつ、何をキャッシュするかを動的にできないかを模索したところ、手段の1つとしてメッセージングを使う方法が浮かんだ。 fetchイベントでリクエスト内容を見て動的に判断するなどはできるが、後述の Service Workerが最長24時間更新されない問題 などもあるので、コントロール手段のひとつとして覚えておくのは良さ気。 メッセージングでService Workerのコントロール Service WorkerはJavaScript Workerのひとつ。なので、ブラウザスレッドとService Workerとでメッセージのやり取りが可能。Cache APIもPromiseな設計なので、e.waitUntil()もあることだし処理はPromiseで書くと良さ気。 // browser.js function sendMessage(message) { return new Promise((resolve, reject) =&gt; { const channel =">
    <meta property="og:description" content="メッセージングによるService Workerのコントロール Service Workerでハンドルするリソースは、Service Workerのスクリプトに静的に記述しているケースが多い。Service Workerでやっているアレコレをメッセージングで動的にできないか試行錯誤したログ。 よくある?キャッシュパターン チュートリアル等でもよく見かける、Service Workerのインストール時に指定のリソースをキャッシュしているパターン。 const CACHE_KEY = &#39;cache-key&#39;; const CACHE_LIST = [ &#39;index.html&#39;, &#39;app.js&#39;, &#39;app.css&#39; ]; self.addEventListener(&#39;install&#39;, e =&gt; { // CACHE_KEYをキーにとるCacheオブジェクトを開いて // CACHE_LISTをキャッシュするPromise let promise = caches.open(CACHE_KEY) .then(cache =&gt; cache.addAll(CACHE_LIST)) .catch(error =&gt; console.log(error)); e.waitUntil(promise); }); 小さい用途であれば、これで何ら問題はない気はする。開発規模が大きくなってくるとリソースの増加やらで人力でメンテナンスするのが辛くなってくる。 GoogleChrome/sw-precacheはService Workerのスクリプトを書き出すツールで、キャッシュしたいパスのパターン指定などが可能。これでひとまず人力で管理していくリスクは低減できるが、細かい処理を書くには不向き。なので、Service Workerの処理内容を自由に書く余地を残しつつ、何をキャッシュするかを動的にできないかを模索したところ、手段の1つとしてメッセージングを使う方法が浮かんだ。 fetchイベントでリクエスト内容を見て動的に判断するなどはできるが、後述の Service Workerが最長24時間更新されない問題 などもあるので、コントロール手段のひとつとして覚えておくのは良さ気。 メッセージングでService Workerのコントロール Service WorkerはJavaScript Workerのひとつ。なので、ブラウザスレッドとService Workerとでメッセージのやり取りが可能。Cache APIもPromiseな設計なので、e.waitUntil()もあることだし処理はPromiseで書くと良さ気。 // browser.js function sendMessage(message) { return new Promise((resolve, reject) =&gt; { const channel =">
    <meta name="twitter:description" content="メッセージングによるService Workerのコントロール Service Workerでハンドルするリソースは、Service Workerのスクリプトに静的に記述しているケースが多い。Service Workerでやっているアレコレをメッセージングで動的にできないか試行錯誤したログ。 よくある?キャッシュパターン チュートリアル等でもよく見かける、Service Workerのインストール時に指定のリソースをキャッシュしているパターン。 const CACHE_KEY = &#39;cache-key&#39;; const CACHE_LIST = [ &#39;index.html&#39;, &#39;app.js&#39;, &#39;app.css&#39; ]; self.addEventListener(&#39;install&#39;, e =&gt; { // CACHE_KEYをキーにとるCacheオブジェクトを開いて // CACHE_LISTをキャッシュするPromise let promise = caches.open(CACHE_KEY) .then(cache =&gt; cache.addAll(CACHE_LIST)) .catch(error =&gt; console.log(error)); e.waitUntil(promise); }); 小さい用途であれば、これで何ら問題はない気はする。開発規模が大きくなってくるとリソースの増加やらで人力でメンテナンスするのが辛くなってくる。 GoogleChrome/sw-precacheはService Workerのスクリプトを書き出すツールで、キャッシュしたいパスのパターン指定などが可能。これでひとまず人力で管理していくリスクは低減できるが、細かい処理を書くには不向き。なので、Service Workerの処理内容を自由に書く余地を残しつつ、何をキャッシュするかを動的にできないかを模索したところ、手段の1つとしてメッセージングを使う方法が浮かんだ。 fetchイベントでリクエスト内容を見て動的に判断するなどはできるが、後述の Service Workerが最長24時間更新されない問題 などもあるので、コントロール手段のひとつとして覚えておくのは良さ気。 メッセージングでService Workerのコントロール Service WorkerはJavaScript Workerのひとつ。なので、ブラウザスレッドとService Workerとでメッセージのやり取りが可能。Cache APIもPromiseな設計なので、e.waitUntil()もあることだし処理はPromiseで書くと良さ気。 // browser.js function sendMessage(message) { return new Promise((resolve, reject) =&gt; { const channel =">
  

  
    <meta property="og:image" content="https://1000ch.net/favicon.svg">
    <meta name="twitter:image" content="https://1000ch.net/favicon.svg">
  


<meta property="og:type" content="article">
<meta property="og:url" content="https://1000ch.net/posts/2016/service-worker-message.html">
<meta property="og:site_name" content="1000ch.net">
<meta property="og:title" content="メッセージングによるService Workerのコントロール">

<meta name="twitter:site" content="@1000ch">
<meta name="twitter:url" content="https://1000ch.net/posts/2016/service-worker-message.html">
<meta name="twitter:title" content="メッセージングによるService Workerのコントロール">

<meta name="google-site-verification" content="BWewniqiBzRmrhpj51eLwug-F4hamFfyznl-ARb-Y4Y">
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon.png">
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="/img/apple-touch-icon.png">
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="/img/apple-touch-icon.png">
<link rel="apple-touch-icon-precomposed" href="/img/apple-touch-icon.png">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-49530352-1', '1000ch.net');
  ga('send', 'pageview');
</script>

  </head>
  <body>
    <div class="Container">
      <header class="Header">
  <h1 class="Header__Title"><a href="/">1000ch.net</a></h1>
  <nav class="Header__Menu">
    <div class="Header__MenuItem">
      <i class="fa fa-rss"></i>
      <a href="/rss.xml">RSS</a>
    </div>
    <div class="Header__MenuItem">
      <i class="fa fa-heart"></i>
      <a href="/activity.html">Activity</a>
    </div>
    <div class="Header__MenuItem">
      <i class="fa fa-facebook-square"></i>
      <a href="https://www.facebook.com/1000ch.net">Facebook</a>
    </div>
  </nav>
</header>

      <div class="Main">
        <span class="Label Label--gray pull-left">2016.05.13</span>

        

<h1 id="メッセージングによるservice-workerのコントロール:238e3693b6f03500fdf98658862a07f7">メッセージングによるService Workerのコントロール</h1>

<p>Service Workerでハンドルするリソースは、Service Workerのスクリプトに静的に記述しているケースが多い。Service Workerでやっているアレコレをメッセージングで動的にできないか試行錯誤したログ。</p>

<h2 id="よくある-キャッシュパターン:238e3693b6f03500fdf98658862a07f7">よくある?キャッシュパターン</h2>

<p>チュートリアル等でもよく見かける、Service Workerのインストール時に指定のリソースをキャッシュしているパターン。</p>

<pre><code class="language-javascript">const CACHE_KEY = 'cache-key';
const CACHE_LIST = [
  'index.html',
  'app.js',
  'app.css'
];

self.addEventListener('install', e =&gt; {
  // CACHE_KEYをキーにとるCacheオブジェクトを開いて
  // CACHE_LISTをキャッシュするPromise
  let promise = caches.open(CACHE_KEY)
    .then(cache =&gt; cache.addAll(CACHE_LIST))
    .catch(error =&gt; console.log(error));

  e.waitUntil(promise);
});
</code></pre>

<p>小さい用途であれば、これで何ら問題はない気はする。開発規模が大きくなってくるとリソースの増加やらで人力でメンテナンスするのが辛くなってくる。</p>

<p><a href="https://github.com/GoogleChrome/sw-precache">GoogleChrome/sw-precache</a>はService Workerのスクリプトを書き出すツールで、キャッシュしたいパスのパターン指定などが可能。これでひとまず人力で管理していくリスクは低減できるが、細かい処理を書くには不向き。なので、Service Workerの処理内容を自由に書く余地を残しつつ、何をキャッシュするかを動的にできないかを模索したところ、手段の1つとしてメッセージングを使う方法が浮かんだ。</p>

<p><code>fetch</code>イベントでリクエスト内容を見て動的に判断するなどはできるが、後述の <strong>Service Workerが最長24時間更新されない問題</strong> などもあるので、コントロール手段のひとつとして覚えておくのは良さ気。</p>

<h2 id="メッセージングでservice-workerのコントロール:238e3693b6f03500fdf98658862a07f7">メッセージングでService Workerのコントロール</h2>

<p>Service Workerは<a href="http://www.html5rocks.com/ja/tutorials/workers/basics/">JavaScript Worker</a>のひとつ。なので、ブラウザスレッドとService Workerとでメッセージのやり取りが可能。Cache APIもPromiseな設計なので、<code>e.waitUntil()</code>もあることだし処理はPromiseで書くと良さ気。</p>

<pre><code class="language-javascript">// browser.js
function sendMessage(message) {
  return new Promise((resolve, reject) =&gt; {
    const channel = new MessageChannel();
    channel.port1.onmessage = e =&gt; {
      if (e.data.error) {
        reject(e.data.error);
      } else {
        resolve(e.data);
      }
    };

    navigator.serviceWorker.controller.postMessage(message, [channel.port2]);
  });
}

sendMessage('A message to Service Worker!');
</code></pre>

<pre><code class="language-javascript">// service-worker.js
self.addEventListener('message', e =&gt; {
  let promise = Promise.resolve()
    .then(() =&gt; {
      console.log(e.data);
      // e.dataにメッセージの内容が入ってる
    })
    .catch(error =&gt; {
      console.error(error);
    });

  e.waitUntil(promise);
});
</code></pre>

<p>例えば、ブラウザから送るメッセージを<code>{ command : 'add', url : 'app.css' }</code>なオブジェクトにすれば、<code>e.data.command</code>で<code>switch</code>するなどして、メッセージの内容に応じた処理も可能。実際にこのメッセージを元に<code>app.css</code>をキャッシュさせる実装をすると次のようになる。</p>

<pre><code class="language-javascript">// browser.js
sendMessage({
  command : 'add',
  url     : 'app.css'
});
</code></pre>

<pre><code class="language-javascript">// service-worker.js
self.addEventListener('message', e =&gt; {
  let promise = caches.open('cache-key')
    .then(() =&gt; {
      let command = e.data.command; // add
      let url = e.data.url;         // app.css
      switch (command) {
        case 'add':
          // app.css のリクエストオブジェクト
          let request = new Request(url);

          // fetch() してレスポンスをキャッシュに格納する
          return fetch(request)
            .then(response =&gt; cache.put(url, response));
        default:
          return Promise.resolve();
      }
    })
    .catch(error =&gt; {
      console.error(error);
    });

  e.waitUntil(promise);
});
</code></pre>

<p>こんな感じで、キャッシュのリソース追加だけでなくリソース削除やキャッシュそのものの削除まで出来ることを確認した。</p>

<h2 id="使いどころ:238e3693b6f03500fdf98658862a07f7">使いどころ</h2>

<p>メッセージングでリソースの追加・削除をする不都合は、 <strong>何をキャッシュさせているか</strong> を管理しにくくなるところか。キャッシュにヒットするかどうかだけなら<code>fetch</code>イベント内でハンドルすれば十分だが、Service Workerはブラウザが必要に応じて起動・終了するので、メッセージの内容を変数に格納して保持しておくことは出来ない。やるならIndexedDBを使うことになりそうだが、キャッシュリストの管理のために、Cache APIとIndexedDBを併用するのも微妙に思う。</p>

<p>Service Workerで唯一使いにくい可能性があるのは、<a href="http://blog.nhiroki.jp/2015/06/22/service-worker-update">Service Worker自体の更新チェックが最大24時間になってしまう点</a>。Service Worker自体に更新があるかどうかは<a href="https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#service-worker-registration-update-method"><code>ServiceWorkerRegistration#update()</code></a>を介してチェックが可能だが、Cache-Controlで長生き設定されていると、たとえページロードのタイミングで毎回呼んだとしてもブラウザキャッシュが効いてしまう（長生き設定しなければ良いという話でもあるんだけど）。</p>

<p>その点、メッセージ経由でキャッシュの全クリアとかもできるので、<code>purge</code>コマンドを用意して失敗ビルドを配信してキャッシュされてしまったような状況に備えるのは悪くないかもしれない。パージの他にも、キャッシュ追加・キャッシュ削除・キャッシュリストの取得といった処理のミニマム実装は<a href="https://github.com/1000ch/sw-sandbox">1000ch/sw-sandbox</a>にあげた。</p>

<p>良い使い方が浮かんだら書き足す。</p>

        <aside class="Share">
  <div class="Share__Item">
     <a href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2f1000ch.net%2fposts%2f2016%2fservice-worker-message.html" title="Share on Facebook" target="_blank">
       <i class="fa fa-facebook-square"></i>
     </a>
  </div>
  <div class="Share__Item">
    <a href="https://twitter.com/share?url=https%3a%2f%2f1000ch.net%2fposts%2f2016%2fservice-worker-message.html&text=%e3%83%a1%e3%83%83%e3%82%bb%e3%83%bc%e3%82%b8%e3%83%b3%e3%82%b0%e3%81%ab%e3%82%88%e3%82%8bService%20Worker%e3%81%ae%e3%82%b3%e3%83%b3%e3%83%88%e3%83%ad%e3%83%bc%e3%83%ab" title="Share on Twitter" target="_blank">
      <i class="fa fa-twitter-square"></i>
    </a>
  </div>
  <div class="Share__Item">
    <a href="https://plus.google.com/share?url=https%3a%2f%2f1000ch.net%2fposts%2f2016%2fservice-worker-message.html" title="Share on Google+" target="_blank">
      <i class="fa fa-google-plus-square"></i>
    </a>
  </div>
</aside>

<nav class="Pager">
  
    <div class="Pager__Item Pager__Item--left">
      <i class="fa fa-arrow-left"></i>
      <a href="/posts/2016/color-picker.html">D3.jsでColor Pickerを作った</a>
    </div>
  

  
    <div class="Pager__Item Pager__Item--right">
      <a href="/posts/2016/intersection-observer-lazyload.html">IntersectionObserverを使ってlazyload-imageを書き直した</a>
      <i class="fa fa-arrow-right"></i>
    </div>
  
</nav>

      </div>
      <aside class="Aside">
  <h1>Author</h1>
  <div class="Media">
    <img class="Media__figure" src="/img/1000ch.jpg" alt="1000ch" width="96" height="96">
    <div class="Media__body">
      <div class="Media__title">1000ch <a href="https://twitter.com/1000ch" class="twitter-follow-button" data-show-count="false" data-show-screen-name="false">Follow @1000ch</a></div>
      <div class="Media__description">
        渋谷で働くソフトウェアエンジニア。Web Standards、パフォーマンス、アクセシビリティあたりのキーワードに反応します。
      </div>
    </div>
  </div>
</aside>

      <footer class="Footer">
  <div class="Banner">
    <div class="Banner__Item">
      <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.ja" target="_blank">
        <img src="/img/by-nc-nd.png" alt="CC BY-NC-ND 4.0" width="80" height="28">
      </a>
    </div>
    <div class="Banner__Item">
      <a href="https://cloud.feedly.com/#subscription%2Ffeed%2Fhttp%3A%2F%2Fhttps%3A%2F%2F1000ch.net%2Findex.xml" target="_blank">
        <img src="https://s3.feedly.com/img/follows/feedly-follow-rectangle-flat-medium_2x.png" alt="follow me on feedly" width="71" height="28">
      </a>
    </div>
    <div class="Banner__Item">
      <form action="https://duckduckgo.com/" role="search">
        <input name="sites" type="hidden" value="1000ch.net">
        <input name="q" type="search">
        <input type="submit" value="Search">
      </form>
    </div>
  </div>
</footer>

    </div>
    <script async src="//apis.google.com/js/plusone.js"></script>
<script async src="//platform.twitter.com/widgets.js"></script>
<script async src="//platform.instagram.com/en_US/embeds.js"></script>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
<script src="/js/app.min.js"></script>

  </body>
</html>
