<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>パフォーマンスに関する各種ブラウザAPI - 1000ch.net</title>

<link rel="icon" href="/favicon.png">
<link rel="shortcut icon" href="/favicon.png">
<link rel="shortcut icon" href="/favicon.svg" type="image/svg+xml" sizes="any">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,700">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto Mono:400,700">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/github.min.css">
<link rel="stylesheet" href="/css/app.min.css">
<link rel="alternate" href="/rss.xml" title="1000ch.net" type="application/rss+xml">

<meta name="author" content="Shogo Sensui">
<meta name="copyright" content="Copyright (c) Shogo Sensui; Licensed under Creative Commons Attribution-Noncommercial-Share Japan">


  
    <meta name="description" content="パフォーマンスに関する各種ブラウザAPI ◯◯ Timing APIはW3CのWeb Performance Working GroupのIlya Grigorikを中心に策定が進められている、ブラウザのパフォーマンスを計測するブラウザAPIである。 User Timing API: 任意のラベルを用いてプログラムの実行にかかったを取得する Navigation Timing API: ブラウザライフサイクルの発生した時間を取得する Resource Timing API: リソースのロードに際して発生した各種時間を取得する Frame Timing API: ブラウザフレームの内訳を取得する Server Timing API: サーバー処理の内訳を取得する High Resolution Time API: 高精度のタイムスタンプを提供する ブラウザのwindowオブジェクトにperformanceというプロパティがあるので、DevToolsを開いてConsoleパネルでwindow.performanceと入力すると、何やら見覚えのあるプロパティに数値が入っているのがわかる。 なかでもFrame TimingとServer Timingは若く、ブラウザに実験的実装はおろかスペックに関する資料も少ない。ここで記載している内容はこれから変わる可能性は高いのでご注意を。 User Timing API User Timing APIは、performance.mark()とperformance.measure()で任意のタイミングのパフォーマンスを計測するAPI。performance.mark()で任意のタイミングにマークをし、performance.measure()でマーク間の差分を取得するような使い方。 以下はXMLHttpRequestによる非同期リクエストのパフォーマンスを計測する例。performance.mark()やperformance.measure()したデータは、performance.getEntriesByType(&#39;mark&#39;)のように計測タイプを指定して取得可能になっている。 let xhr = new XMLHttpRequest(); xhr.open(&#39;GET&#39;, &#39;/&#39;, true); xhr.onload = e =&gt; { performance.mark(&#39;mark-xhr-end&#39;); performance.measure(&#39;xhr-start-end&#39;, &#39;mark-xhr-start&#39;, &#39;mark-xhr-end&#39;); console.log(performance.getEntriesByType(&#39;mark&#39;)); console.log(performance.getEntriesByType(&#39;measure&#39;)); }; performance.mark(&#39;mark-xhr-start&#39;); xhr.send(); 以前まではDevToolsのTimelineパネルにこのマークした情報が表示されていたが、53周辺では消えている気がする。Canaryだからかもしれないけど。 Navigation Timing API">
    <meta property="og:description" content="パフォーマンスに関する各種ブラウザAPI ◯◯ Timing APIはW3CのWeb Performance Working GroupのIlya Grigorikを中心に策定が進められている、ブラウザのパフォーマンスを計測するブラウザAPIである。 User Timing API: 任意のラベルを用いてプログラムの実行にかかったを取得する Navigation Timing API: ブラウザライフサイクルの発生した時間を取得する Resource Timing API: リソースのロードに際して発生した各種時間を取得する Frame Timing API: ブラウザフレームの内訳を取得する Server Timing API: サーバー処理の内訳を取得する High Resolution Time API: 高精度のタイムスタンプを提供する ブラウザのwindowオブジェクトにperformanceというプロパティがあるので、DevToolsを開いてConsoleパネルでwindow.performanceと入力すると、何やら見覚えのあるプロパティに数値が入っているのがわかる。 なかでもFrame TimingとServer Timingは若く、ブラウザに実験的実装はおろかスペックに関する資料も少ない。ここで記載している内容はこれから変わる可能性は高いのでご注意を。 User Timing API User Timing APIは、performance.mark()とperformance.measure()で任意のタイミングのパフォーマンスを計測するAPI。performance.mark()で任意のタイミングにマークをし、performance.measure()でマーク間の差分を取得するような使い方。 以下はXMLHttpRequestによる非同期リクエストのパフォーマンスを計測する例。performance.mark()やperformance.measure()したデータは、performance.getEntriesByType(&#39;mark&#39;)のように計測タイプを指定して取得可能になっている。 let xhr = new XMLHttpRequest(); xhr.open(&#39;GET&#39;, &#39;/&#39;, true); xhr.onload = e =&gt; { performance.mark(&#39;mark-xhr-end&#39;); performance.measure(&#39;xhr-start-end&#39;, &#39;mark-xhr-start&#39;, &#39;mark-xhr-end&#39;); console.log(performance.getEntriesByType(&#39;mark&#39;)); console.log(performance.getEntriesByType(&#39;measure&#39;)); }; performance.mark(&#39;mark-xhr-start&#39;); xhr.send(); 以前まではDevToolsのTimelineパネルにこのマークした情報が表示されていたが、53周辺では消えている気がする。Canaryだからかもしれないけど。 Navigation Timing API">
    <meta name="twitter:description" content="パフォーマンスに関する各種ブラウザAPI ◯◯ Timing APIはW3CのWeb Performance Working GroupのIlya Grigorikを中心に策定が進められている、ブラウザのパフォーマンスを計測するブラウザAPIである。 User Timing API: 任意のラベルを用いてプログラムの実行にかかったを取得する Navigation Timing API: ブラウザライフサイクルの発生した時間を取得する Resource Timing API: リソースのロードに際して発生した各種時間を取得する Frame Timing API: ブラウザフレームの内訳を取得する Server Timing API: サーバー処理の内訳を取得する High Resolution Time API: 高精度のタイムスタンプを提供する ブラウザのwindowオブジェクトにperformanceというプロパティがあるので、DevToolsを開いてConsoleパネルでwindow.performanceと入力すると、何やら見覚えのあるプロパティに数値が入っているのがわかる。 なかでもFrame TimingとServer Timingは若く、ブラウザに実験的実装はおろかスペックに関する資料も少ない。ここで記載している内容はこれから変わる可能性は高いのでご注意を。 User Timing API User Timing APIは、performance.mark()とperformance.measure()で任意のタイミングのパフォーマンスを計測するAPI。performance.mark()で任意のタイミングにマークをし、performance.measure()でマーク間の差分を取得するような使い方。 以下はXMLHttpRequestによる非同期リクエストのパフォーマンスを計測する例。performance.mark()やperformance.measure()したデータは、performance.getEntriesByType(&#39;mark&#39;)のように計測タイプを指定して取得可能になっている。 let xhr = new XMLHttpRequest(); xhr.open(&#39;GET&#39;, &#39;/&#39;, true); xhr.onload = e =&gt; { performance.mark(&#39;mark-xhr-end&#39;); performance.measure(&#39;xhr-start-end&#39;, &#39;mark-xhr-start&#39;, &#39;mark-xhr-end&#39;); console.log(performance.getEntriesByType(&#39;mark&#39;)); console.log(performance.getEntriesByType(&#39;measure&#39;)); }; performance.mark(&#39;mark-xhr-start&#39;); xhr.send(); 以前まではDevToolsのTimelineパネルにこのマークした情報が表示されていたが、53周辺では消えている気がする。Canaryだからかもしれないけど。 Navigation Timing API">
  

  
    <meta property="og:image" content="https://1000ch.net/favicon.svg">
    <meta name="twitter:image" content="https://1000ch.net/favicon.svg">
  


<meta property="og:type" content="article">
<meta property="og:url" content="https://1000ch.net/posts/2016/performance-api.html">
<meta property="og:site_name" content="1000ch.net">
<meta property="og:title" content="パフォーマンスに関する各種ブラウザAPI">

<meta name="twitter:site" content="@1000ch">
<meta name="twitter:url" content="https://1000ch.net/posts/2016/performance-api.html">
<meta name="twitter:title" content="パフォーマンスに関する各種ブラウザAPI">

<meta name="google-site-verification" content="BWewniqiBzRmrhpj51eLwug-F4hamFfyznl-ARb-Y4Y">
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon.png">
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="/img/apple-touch-icon.png">
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="/img/apple-touch-icon.png">
<link rel="apple-touch-icon-precomposed" href="/img/apple-touch-icon.png">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-49530352-1', '1000ch.net');
  ga('send', 'pageview');
</script>

  </head>
  <body>
    <div class="Container">
      <header class="Header">
  <h1 class="Header__Title"><a href="/">1000ch.net</a></h1>
  <nav class="Header__Menu">
    <div class="Header__MenuItem">
      <i class="fa fa-rss"></i>
      <a href="/rss.xml">RSS</a>
    </div>
    <div class="Header__MenuItem">
      <i class="fa fa-heart"></i>
      <a href="/activity.html">Activity</a>
    </div>
    <div class="Header__MenuItem">
      <i class="fa fa-facebook-square"></i>
      <a href="https://www.facebook.com/1000ch.net">Facebook</a>
    </div>
  </nav>
</header>

      <div class="Main">
        <span class="Label Label--gray pull-left">2016.06.14</span>

        

<h1 id="パフォーマンスに関する各種ブラウザapi:2f60f0ed9935eac35bfa25f474190847">パフォーマンスに関する各種ブラウザAPI</h1>

<p>◯◯ Timing APIはW3CのWeb Performance Working GroupのIlya Grigorikを中心に策定が進められている、ブラウザのパフォーマンスを計測するブラウザAPIである。</p>

<ul>
<li><a href="http://w3c.github.io/user-timing/">User Timing API</a>: 任意のラベルを用いてプログラムの実行にかかったを取得する</li>
<li><a href="http://w3c.github.io/navigation-timing/">Navigation Timing API</a>: ブラウザライフサイクルの発生した時間を取得する</li>
<li><a href="http://w3c.github.io/resource-timing/">Resource Timing API</a>: リソースのロードに際して発生した各種時間を取得する</li>
<li><a href="http://w3c.github.io/frame-timing/">Frame Timing API</a>: ブラウザフレームの内訳を取得する</li>
<li><a href="https://w3c.github.io/server-timing/">Server Timing API</a>: サーバー処理の内訳を取得する</li>
<li><a href="http://w3c.github.io/hr-time/">High Resolution Time API</a>: 高精度のタイムスタンプを提供する</li>
</ul>

<p>ブラウザの<code>window</code>オブジェクトに<code>performance</code>というプロパティがあるので、DevToolsを開いてConsoleパネルで<code>window.performance</code>と入力すると、何やら見覚えのあるプロパティに数値が入っているのがわかる。</p>

<p>なかでもFrame TimingとServer Timingは若く、ブラウザに実験的実装はおろかスペックに関する資料も少ない。ここで記載している内容はこれから変わる可能性は高いのでご注意を。</p>

<h2 id="user-timing-api:2f60f0ed9935eac35bfa25f474190847">User Timing API</h2>

<p><a href="https://w3c.github.io/user-timing/">User Timing API</a>は、<code>performance.mark()</code>と<code>performance.measure()</code>で任意のタイミングのパフォーマンスを計測するAPI。<code>performance.mark()</code>で任意のタイミングにマークをし、<code>performance.measure()</code>でマーク間の差分を取得するような使い方。</p>

<p>以下は<code>XMLHttpRequest</code>による非同期リクエストのパフォーマンスを計測する例。<code>performance.mark()</code>や<code>performance.measure()</code>したデータは、<code>performance.getEntriesByType('mark')</code>のように計測タイプを指定して取得可能になっている。</p>

<pre><code class="language-javascript">let xhr = new XMLHttpRequest();
xhr.open('GET', '/', true);
xhr.onload = e =&gt; {
  performance.mark('mark-xhr-end');
  performance.measure('xhr-start-end', 'mark-xhr-start', 'mark-xhr-end');
  console.log(performance.getEntriesByType('mark'));
  console.log(performance.getEntriesByType('measure'));
};
performance.mark('mark-xhr-start');
xhr.send();
</code></pre>

<p>以前まではDevToolsのTimelineパネルにこのマークした情報が表示されていたが、53周辺では消えている気がする。Canaryだからかもしれないけど。</p>

<h2 id="navigation-timing-api:2f60f0ed9935eac35bfa25f474190847">Navigation Timing API</h2>

<p><a href="https://w3c.github.io/navigation-timing/">Navigation Timing API</a>は、ブラウザのページロード完了までの<code>DOMContentLoaded</code>や<code>load</code>のようなライフサイクルイベントを取得するAPI。</p>

<p><img src="/img/posts/2016/performance-api/processing-model.svg" alt="Processing Model" /></p>

<p><code>performance.timing</code>から以下の情報を取得できる。</p>

<pre><code class="language-javascript">console.log(
  'Name: '       + performance.timing.name      + '\n' +
  'Entry Type: ' + performance.timing.entryType + '\n' +
  'Start Time: ' + performance.timing.startTime + '\n' +
  'Duration: '   + performance.timing.duration  + '\n' +
  'Unload: '     + (performance.timing.unloadEventEnd - performance.timing.unloadEventStart)   + 'n' +
  'Redirect: '   + (performance.timing.redirectEnd - performance.timing.redirectStart)         + 'n' +
  'App Cache: '  + (performance.timing.domainLookupStart - performance.timing.fetchStart)      + 'n' +
  'DNS: '        + (performance.timing.domainLookupEnd - performance.timing.domainLookupStart) + 'n' +
  'TCP: '        + (performance.timing.connectEnd - performance.timing.connectStart)           + 'n' +
  'Request: '    + (performance.timing.responseStart - performance.timing.requestStart)        + 'n' +
  'Response: '   + (performance.timing.responseEnd - performance.timing.responseStart)         + 'n' +
  'Processing: ' + (performance.timing.loadEventStart - performance.timing.responseEnd)        + 'n' +
  'Onload: '     + (performance.timing.loadEventEnd - performance.timing.loadEventStart)       + 'n'
);
</code></pre>

<p>ここから<code>PerformanceEntry</code>などのインターフェースに対応するNavigation Timing Level 2という仕様の策定が進んでいる。これは後述の<code>PerformanceObserver</code>に必要なインターフェースとなっている。</p>

<p><code>DOMContentLoaded</code>や<code>load</code>、<code>document.readyState</code>との対応関係は次のようになりそう。</p>

<table>
<thead>
<tr>
<th>Browser lifecycle</th>
<th><code>document.readyState</code></th>
<th>Navigation Timing API</th>
</tr>
</thead>

<tbody>
<tr>
<td></td>
<td></td>
<td><code>timing.domLoading</code></td>
</tr>

<tr>
<td></td>
<td><code>loading</code></td>
<td></td>
</tr>

<tr>
<td></td>
<td></td>
<td><code>timing.domInteractive</code></td>
</tr>

<tr>
<td></td>
<td><code>interactive</code></td>
<td></td>
</tr>

<tr>
<td><code>DOMContentLoaded</code></td>
<td></td>
<td><code>timing.domContentLoadedEventStart</code></td>
</tr>

<tr>
<td></td>
<td></td>
<td><code>timing.domContentLoadedEventEnd</code></td>
</tr>

<tr>
<td></td>
<td></td>
<td><code>timing.domComplete</code></td>
</tr>

<tr>
<td></td>
<td><code>complete</code></td>
<td></td>
</tr>

<tr>
<td><code>load</code></td>
<td></td>
<td><code>timing.loadEvent</code></td>
</tr>
</tbody>
</table>

<h2 id="resource-timing-api:2f60f0ed9935eac35bfa25f474190847">Resource Timing API</h2>

<p><a href="https://w3c.github.io/resource-timing/">Resource Timing API</a>はページ内でロードされたリソースに関する情報を取得するAPI。雑に言えばNavigation Timing APIのサブリソース版。</p>

<p><code>performance.getEntriesByType()</code>に<code>resource</code>を指定して取得する。</p>

<pre><code class="language-javascript">for (let resource of performance.getEntriesByType('resource')) {
  console.log(
    'Name: '       + resource.name      + '\n' +
    'Entry Type: ' + resource.entryType + '\n' +
    'Start Time: ' + resource.startTime + '\n' +
    'Duration: '   + resource.duration  + '\n' +
    'Redirect: '   + (resource.redirectEnd - resource.redirectStart)         + 'n' +
    'App Cache: '  + (resource.domainLookupStart - resource.fetchStart)      + 'n' +
    'DNS: '        + (resource.domainLookupEnd - resource.domainLookupStart) + 'n' +
    'TCP: '        + (resource.connectEnd - resource.connectStart)           + 'n' +
    'Request: '    + (resource.responseStart - resource.requestStart)        + 'n' +
    'Response: '   + (resource.responseEnd - resource.responseStart)         + 'n' +
    'Processing: ' + (resource.loadEventStart - resource.responseEnd)        + 'n'
  );
}
</code></pre>

<h2 id="frame-timing-api:2f60f0ed9935eac35bfa25f474190847">Frame Timing API</h2>

<p><a href="https://w3c.github.io/frame-timing/">Frame Timing API</a>はページ描画のフレーム情報を取得するAPI。Navigation Timing APIやResource Timing APIはネットワーク処理に関するパフォーマンスの情報だが、これはレンダリングパフォーマンスの情報ということになる。</p>

<p>1フレームはイベントループにおける<code>vsync</code>から<code>vsync</code>までを指す。</p>

<p><img src="/img/posts/2016/performance-api/frame-model.png" alt="Frame Model" /></p>

<p><code>performance.getEntriesByType()</code>に<code>renderer</code>ないし<code>composite</code>を指定して取得する。</p>

<pre><code class="language-javascript">for (let renderer of performance.getEntriesByType('renderer')) {
  console.log(
    'Name: '       + renderer.name      + '\n' +
    'Entry Type: ' + renderer.entryType + '\n' +
    'Start Time: ' + renderer.startTime + '\n' +
    'Duration: '   + renderer.duration  + '\n'
  );
}

for (let composite of performance.getEntriesByType('composite')) {
  console.log(
    'Name: '       + composite.name      + '\n' +
    'Entry Type: ' + composite.entryType + '\n' +
    'Start Time: ' + composite.startTime + '\n' +
    'Duration: '   + composite.duration  + '\n'
  );
}
</code></pre>

<p><code>renderer</code>はメインスレッドからCompositorへ行われるコミット、<code>composite</code>はCompositorからのドローコールに関する情報である。</p>

<p>これらは必ずしも対にはならず、Compositorからのドローコールはメインスレッドからのコミットに依存しない。例えばスクロールなんかの時はビットマップの再構築をせずディスプレイへのピクセルを送り直すということだと思われる。たぶん。</p>

<h2 id="server-timing-api:2f60f0ed9935eac35bfa25f474190847">Server Timing API</h2>

<p><a href="https://w3c.github.io/server-timing/">Server Timing API</a>は、レスポンスヘッダの<code>Server-Timing</code>フィールドにサーバーの各処理にかかった時間を含めて、クライアントでそれを参照できるようにしようというAPI。IlyaのGist（<a href="https://gist.github.com/igrigorik/97dfe5ea9b4a85162e25">igrigorik/server-timing.md</a>）レベルなので、まだまだ仕様の着地には遠そうだが、便利そう。</p>

<pre><code>HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
Cache-Control: max-age=360, public
Transfer-Encoding: chunked
Server-Timing: db=150; cache=22
</code></pre>

<p>レスポンスヘッダの<code>Server-Timing</code>フィールドがあれば、この場合はDBアクセスに150msかかり、キャッシュの参照に22msかかったということが表せる。</p>

<p><code>performance.getEntriesByType()</code>に<code>server</code>を指定して取得する。</p>

<pre><code class="language-javascript">for (let server of performance.getEntriesByType('server')) {
  console.log(
    'Name: '        + renderer.name        + '\n' +
    'Entry Type: '  + renderer.entryType   + '\n' +
    'Start Time: '  + renderer.startTime   + '\n' +
    'Duration: '    + renderer.duration    + '\n' +
    'Metric: '      + renderer.metric      + '\n' +
    'Description: ' + renderer.description + '\n'
  );
}
</code></pre>

<h2 id="high-resolution-time-api:2f60f0ed9935eac35bfa25f474190847">High Resolution Time API</h2>

<p><a href="https://www.w3.org/TR/hr-time/">High Resolution Time API</a>はマイクロ秒単位でパフォーマンスを計測するためのAPI。<code>Date.now()</code>のミリ秒では不十分ということで、細かな計測には<code>performance.now()</code>を使うと良い。</p>

<p><code>performance.now()</code>が返す<code>DOMHighResTimeStamp</code>は、ここまで紹介してきた各APIの時間に関するプロパティでも使われている。内部的にはただの<code>double</code>である。</p>

<h2 id="performance-observer:2f60f0ed9935eac35bfa25f474190847">Performance Observer</h2>

<p>ブラウザパフォーマンスを計測するAPIは先に挙げた、User Timing API・Navigation Timing API・Resource Timing API・Frame Timing API・Server Timing APIの5つがある。<a href="https://w3c.github.io/performance-timeline/">Performance Observer</a>はこれらの変更を監視するAPIである。</p>

<p><code>PerformanceObserver</code>のインスタンスを作り、監視開始には<code>observe()</code>、終了には<code>disconnect()</code>を実行する。</p>

<pre><code class="language-javascript">const observer = new PerformanceObserver(list =&gt; {
  for (let entry of list.getEntries()) {
    console.log(
      'Name: '       + entry.name      + '\n' +
      'Entry Type: ' + entry.entryType + '\n' +
      'Start Time: ' + entry.startTime + '\n' +
      'Duration: '   + entry.duration  + '\n'
    );
  }
});

observer.observe({
  entryTypes : ['resource']
});

observer.disconnect();
</code></pre>

<p><code>observe()</code>の引数にはどの種類のパフォーマンスのタイムスタンプを監視するかを指定してあげる。ここではResource Timing APIで取得する値を監視するべく<code>resource</code>を指定しているが、ここまで<code>performance.getEntriesByType()</code>の引数に指定してきた文字列を取りうる。</p>

<p>メトリクス毎に<code>PerformanceObserver</code>を分けるなどの使い方も可能だろう。</p>

        <aside class="Share">
  <div class="Share__Item">
     <a href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2f1000ch.net%2fposts%2f2016%2fperformance-api.html" title="Share on Facebook" target="_blank">
       <i class="fa fa-facebook-square"></i>
     </a>
  </div>
  <div class="Share__Item">
    <a href="https://twitter.com/share?url=https%3a%2f%2f1000ch.net%2fposts%2f2016%2fperformance-api.html&text=%e3%83%91%e3%83%95%e3%82%a9%e3%83%bc%e3%83%9e%e3%83%b3%e3%82%b9%e3%81%ab%e9%96%a2%e3%81%99%e3%82%8b%e5%90%84%e7%a8%ae%e3%83%96%e3%83%a9%e3%82%a6%e3%82%b6API" title="Share on Twitter" target="_blank">
      <i class="fa fa-twitter-square"></i>
    </a>
  </div>
  <div class="Share__Item">
    <a href="https://plus.google.com/share?url=https%3a%2f%2f1000ch.net%2fposts%2f2016%2fperformance-api.html" title="Share on Google+" target="_blank">
      <i class="fa fa-google-plus-square"></i>
    </a>
  </div>
</aside>

<nav class="Pager">
  
    <div class="Pager__Item Pager__Item--left">
      <i class="fa fa-arrow-left"></i>
      <a href="/posts/2016/abematv-runtime-perf-audit.html">AbemaTVのランタイムパフォーマンスのAudit</a>
    </div>
  

  
    <div class="Pager__Item Pager__Item--right">
      <a href="/posts/2016/social-button.html">ソーシャルボタンのWeb Components</a>
      <i class="fa fa-arrow-right"></i>
    </div>
  
</nav>

      </div>
      <aside class="Aside">
  <h1>Author</h1>
  <div class="Media">
    <img class="Media__figure" src="/img/1000ch.jpg" alt="1000ch" width="96" height="96">
    <div class="Media__body">
      <div class="Media__title">1000ch <a href="https://twitter.com/1000ch" class="twitter-follow-button" data-show-count="false" data-show-screen-name="false">Follow @1000ch</a></div>
      <div class="Media__description">
        渋谷で働くソフトウェアエンジニア。Web Standards、パフォーマンス、アクセシビリティあたりのキーワードに反応します。
      </div>
    </div>
  </div>
</aside>

      <footer class="Footer">
  <div class="Banner">
    <div class="Banner__Item">
      <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.ja" target="_blank">
        <img src="/img/by-nc-nd.png" alt="CC BY-NC-ND 4.0" width="80" height="28">
      </a>
    </div>
    <div class="Banner__Item">
      <a href="https://cloud.feedly.com/#subscription%2Ffeed%2Fhttp%3A%2F%2Fhttps%3A%2F%2F1000ch.net%2Findex.xml" target="_blank">
        <img src="https://s3.feedly.com/img/follows/feedly-follow-rectangle-flat-medium_2x.png" alt="follow me on feedly" width="71" height="28">
      </a>
    </div>
    <div class="Banner__Item">
      <form action="https://duckduckgo.com/" role="search">
        <input name="sites" type="hidden" value="1000ch.net">
        <input name="q" type="search">
        <input type="submit" value="Search">
      </form>
    </div>
  </div>
</footer>

    </div>
    <script async src="//apis.google.com/js/plusone.js"></script>
<script async src="//platform.twitter.com/widgets.js"></script>
<script async src="//platform.instagram.com/en_US/embeds.js"></script>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
<script src="/js/app.min.js"></script>

  </body>
</html>
