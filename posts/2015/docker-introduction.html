<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Docker事始め作業ログ - 1000ch.net</title>

<link rel="icon" href="/favicon.png">
<link rel="shortcut icon" href="/favicon.png">
<link rel="shortcut icon" href="/favicon.svg" type="image/svg+xml" sizes="any">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,700">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto Mono:400,700">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/github.min.css">
<link rel="stylesheet" href="/css/app.min.css">
<link rel="alternate" href="/rss.xml" title="1000ch.net" type="application/rss+xml">

<meta name="author" content="Shogo Sensui">
<meta name="copyright" content="Copyright (c) Shogo Sensui; Licensed under Creative Commons Attribution-Noncommercial-Share Japan">


  
    <meta name="description" content="Docker事始め作業ログ やってみよう系の記事は既にチラホラあるけど、手元の環境に合わせて書き直したただの作業ログ。 Dockerとは 従来のような物理的な仮想化ではなくコンテナ型仮想化を実現するソフトウェア 例えばLinuxの上に独立したLinuxをシステムを起動できる ハードウェアをシミュレートするのではなくLXCという技術を使ってリソースを隔離する ファイルシステムやプロセス・CPUを共有するので省メモリ・低コストで仮想化できる ざっくりこのような感じだが、パッとこない場合は以下の記事が参考になる。 15分で分かるLXC（Linux Containers）の仕組みと基本的な使い方 クラウド時代のオープンソース実践活用 | 第41回 Linuxコンテナ(LXC)の基礎をまとめ直す Mac OS XにDocker環境を準備する 以下のものをインストールする必要アリ。公式で配布されているDocker Toolboxでも良いが、インストーラ使うとroot領域いじられそうなので、VirtualBox以外はHomebrew経由でインストールする。boot2dockerは使わない。 VirtualBox v5.0.4 docker v1.8.2 docker-machine v0.4.1 $ brew install docker $ brew install docker-machine あとは公式のチュートリアルに沿ってDockerの振る舞いを理解していく。 Docker Machineで仮想マシンを作成する Docker Machineで仮想マシンを立てる。VirtualBoxを使うので、--driverで指定し、マシン名も引数に取る（ここではlocalというマシン名を指定）。作成すると~/.docker/machine/machines/localというフォルダが作成され、マシンの各種設定が保存される。 $ docker-machine create --driver virtualbox local Docker Machineで作成したマシンはlsコマンドでリストアップできる。マシンを削除するにはrmコマンドで。 $ docker-machine ls NAME ACTIVE DRIVER STATE URL SWARM local virtualbox Running tcp://192.168.99.100:2376 $ docker-machine rm local 仮想マシンの各種環境変数 作成したマシンの各種環境変数はenvコマンドで取得可能。出力結果をevalするとそのまま変数を定義できる。 $ docker-machine env local export DOCKER_TLS_VERIFY=&quot;1&quot; export DOCKER_HOST=&quot;tcp://192.168.99.100:2376&quot; export DOCKER_CERT_PATH=&quot;/Users/1000ch/.docker/machine/machines/local&quot; export DOCKER_MACHINE_NAME=&quot;local&quot; # Run this command to configure your shell: # eval &quot;$(docker-machine env local)&quot; hello-worldコンテナを実行してみる 先程のenvコマンドで得られる環境変数をexportした上で、いよいよDockerでコンテナを起動する。今回はhello-worldというコンテナを指定しているが、実行に成功するとハローワールドが表示される。 $ eval &quot;$(docker-machine env local)&quot; $ docker run hello-world ここではhello-worldというコンテナを指定しているが、以下の手順が実施されている。Docketクライアントはコマンドを叩いているターミナルということになる。 DockerクライアントがDockerデーモンに問い合わせる Dockerデーモンがhello-worldイメージをDocker Hubからダウンロードする Docketデーモンがダウンロードしてきたイメージから新たにコンテナを作成する Dockerデーモンがコンテナを標準出力をDocketクライアントに流す nginxコンテナを試してみる バックグラウンドで実行させるために-d（--detach=false）を、ランダムにポートを割り当てるために-P（--publish-all=false）を、明示的に名前を付与すべく--nameも付けて実行する。nginxのプロセスは終了するまで実行され続けるので、-dを付けないとターミナルが持っていかれる。 $ docker run -d -P --name nginx-web nginx 起動中のコンテナ一覧の表示、コンテナの開始と停止と削除 停止にはstopコマンドを、削除にはrmコマンドを使う。それぞれコンテナのID指定するが、コンテナIDは先程のrunコマンドの-dオプションで出力される他、psコマンドの出力結果にも表示される。尚、コンテナに名前が指定されていればコンテナIDではなくコンテナ名を指定しても実行できる。 # 起動中のコンテナ一覧を表示する $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ba377526b912 nginx &quot;nginx -g &#39;daemon off&quot; 26 seconds ago Up 2 seconds 0.0.0.0:32775-&gt;80/tcp, 0.0.0.0:32774-&gt;443/tcp nginx-web # 指定したコンテナを停止する $ docker stop ba377526b912 # 指定したコンテナを開始する $ docker start ba377526b912 # 指定したコンテナを削除する $ docker rm ba377526b912 nginxがホストしているページをブラウザで表示する portコマンドでコンテナに対してマッピングされているポート番号を一覧化できる。先程nginx-webという名前でコンテナを起動したので、それがどのポートに割り当てられているかを確認してみる。 $ docker port nginx-web 443/tcp -&gt; 0.0.0.0:32774 80/tcp -&gt; 0.0.0.0:32775 コンテナの443ポートがローカルホスト（Dockerクライアント）の32774に、コンテナの80ポートがローカルホスト32775にマッピングされているのがわかる。 マシンのIPアドレスを調べる 先程のコンテナのIPアドレスはDockerのホストアドレスではないので、nginxにはアクセスできない。Docker Machineで作成したマシンのIPアドレスをipコマンドを使って調べる。echo $DOCKER_HOSTあたりを実行すると、docker-machine envで出力されたDOCKER_HOSTのIPと一致しているのがわかる。 $ docker-machine ip local 192.168.99.100 $ echo $DOCKER_HOST tcp://192.168.99.100:2376 ブラウザでnginxでホストしているページへアクセスする ここまででnginxが192.168.99.100:32775を待ち構えていることがわかるので、 http://192.168.99.100:32775 にアクセスしてみる。 ローカルのディレクトリをコンテナにマウントする 次に、ローカルのディレクトリをコンテナにマウントしてみる。適当なディレクトリにindex.htmlを配置して、配置したディレクトリをnginxのホストディレクトリにマウントする。それが出来れば先程のURLでindex.htmlの内容が表示されるはずだ。今回はユーザーディレクトリ配下にfooというフォルダを用意し、その中にindex.htmlを配置した。HTMLの中身は何でも良い。 コンテナの再作成からやるので、docker psで起動しているコンテナのコンテナIDを取得し、docker stop [コンテナID]→docker rm [コンテナID]で先程作成したコンテナ（nginx-web）を削除する。削除せずに違う名前でも良いんだけど、テストがてら。 $ docker ps ...">
    <meta property="og:description" content="Docker事始め作業ログ やってみよう系の記事は既にチラホラあるけど、手元の環境に合わせて書き直したただの作業ログ。 Dockerとは 従来のような物理的な仮想化ではなくコンテナ型仮想化を実現するソフトウェア 例えばLinuxの上に独立したLinuxをシステムを起動できる ハードウェアをシミュレートするのではなくLXCという技術を使ってリソースを隔離する ファイルシステムやプロセス・CPUを共有するので省メモリ・低コストで仮想化できる ざっくりこのような感じだが、パッとこない場合は以下の記事が参考になる。 15分で分かるLXC（Linux Containers）の仕組みと基本的な使い方 クラウド時代のオープンソース実践活用 | 第41回 Linuxコンテナ(LXC)の基礎をまとめ直す Mac OS XにDocker環境を準備する 以下のものをインストールする必要アリ。公式で配布されているDocker Toolboxでも良いが、インストーラ使うとroot領域いじられそうなので、VirtualBox以外はHomebrew経由でインストールする。boot2dockerは使わない。 VirtualBox v5.0.4 docker v1.8.2 docker-machine v0.4.1 $ brew install docker $ brew install docker-machine あとは公式のチュートリアルに沿ってDockerの振る舞いを理解していく。 Docker Machineで仮想マシンを作成する Docker Machineで仮想マシンを立てる。VirtualBoxを使うので、--driverで指定し、マシン名も引数に取る（ここではlocalというマシン名を指定）。作成すると~/.docker/machine/machines/localというフォルダが作成され、マシンの各種設定が保存される。 $ docker-machine create --driver virtualbox local Docker Machineで作成したマシンはlsコマンドでリストアップできる。マシンを削除するにはrmコマンドで。 $ docker-machine ls NAME ACTIVE DRIVER STATE URL SWARM local virtualbox Running tcp://192.168.99.100:2376 $ docker-machine rm local 仮想マシンの各種環境変数 作成したマシンの各種環境変数はenvコマンドで取得可能。出力結果をevalするとそのまま変数を定義できる。 $ docker-machine env local export DOCKER_TLS_VERIFY=&quot;1&quot; export DOCKER_HOST=&quot;tcp://192.168.99.100:2376&quot; export DOCKER_CERT_PATH=&quot;/Users/1000ch/.docker/machine/machines/local&quot; export DOCKER_MACHINE_NAME=&quot;local&quot; # Run this command to configure your shell: # eval &quot;$(docker-machine env local)&quot; hello-worldコンテナを実行してみる 先程のenvコマンドで得られる環境変数をexportした上で、いよいよDockerでコンテナを起動する。今回はhello-worldというコンテナを指定しているが、実行に成功するとハローワールドが表示される。 $ eval &quot;$(docker-machine env local)&quot; $ docker run hello-world ここではhello-worldというコンテナを指定しているが、以下の手順が実施されている。Docketクライアントはコマンドを叩いているターミナルということになる。 DockerクライアントがDockerデーモンに問い合わせる Dockerデーモンがhello-worldイメージをDocker Hubからダウンロードする Docketデーモンがダウンロードしてきたイメージから新たにコンテナを作成する Dockerデーモンがコンテナを標準出力をDocketクライアントに流す nginxコンテナを試してみる バックグラウンドで実行させるために-d（--detach=false）を、ランダムにポートを割り当てるために-P（--publish-all=false）を、明示的に名前を付与すべく--nameも付けて実行する。nginxのプロセスは終了するまで実行され続けるので、-dを付けないとターミナルが持っていかれる。 $ docker run -d -P --name nginx-web nginx 起動中のコンテナ一覧の表示、コンテナの開始と停止と削除 停止にはstopコマンドを、削除にはrmコマンドを使う。それぞれコンテナのID指定するが、コンテナIDは先程のrunコマンドの-dオプションで出力される他、psコマンドの出力結果にも表示される。尚、コンテナに名前が指定されていればコンテナIDではなくコンテナ名を指定しても実行できる。 # 起動中のコンテナ一覧を表示する $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ba377526b912 nginx &quot;nginx -g &#39;daemon off&quot; 26 seconds ago Up 2 seconds 0.0.0.0:32775-&gt;80/tcp, 0.0.0.0:32774-&gt;443/tcp nginx-web # 指定したコンテナを停止する $ docker stop ba377526b912 # 指定したコンテナを開始する $ docker start ba377526b912 # 指定したコンテナを削除する $ docker rm ba377526b912 nginxがホストしているページをブラウザで表示する portコマンドでコンテナに対してマッピングされているポート番号を一覧化できる。先程nginx-webという名前でコンテナを起動したので、それがどのポートに割り当てられているかを確認してみる。 $ docker port nginx-web 443/tcp -&gt; 0.0.0.0:32774 80/tcp -&gt; 0.0.0.0:32775 コンテナの443ポートがローカルホスト（Dockerクライアント）の32774に、コンテナの80ポートがローカルホスト32775にマッピングされているのがわかる。 マシンのIPアドレスを調べる 先程のコンテナのIPアドレスはDockerのホストアドレスではないので、nginxにはアクセスできない。Docker Machineで作成したマシンのIPアドレスをipコマンドを使って調べる。echo $DOCKER_HOSTあたりを実行すると、docker-machine envで出力されたDOCKER_HOSTのIPと一致しているのがわかる。 $ docker-machine ip local 192.168.99.100 $ echo $DOCKER_HOST tcp://192.168.99.100:2376 ブラウザでnginxでホストしているページへアクセスする ここまででnginxが192.168.99.100:32775を待ち構えていることがわかるので、 http://192.168.99.100:32775 にアクセスしてみる。 ローカルのディレクトリをコンテナにマウントする 次に、ローカルのディレクトリをコンテナにマウントしてみる。適当なディレクトリにindex.htmlを配置して、配置したディレクトリをnginxのホストディレクトリにマウントする。それが出来れば先程のURLでindex.htmlの内容が表示されるはずだ。今回はユーザーディレクトリ配下にfooというフォルダを用意し、その中にindex.htmlを配置した。HTMLの中身は何でも良い。 コンテナの再作成からやるので、docker psで起動しているコンテナのコンテナIDを取得し、docker stop [コンテナID]→docker rm [コンテナID]で先程作成したコンテナ（nginx-web）を削除する。削除せずに違う名前でも良いんだけど、テストがてら。 $ docker ps ...">
    <meta name="twitter:description" content="Docker事始め作業ログ やってみよう系の記事は既にチラホラあるけど、手元の環境に合わせて書き直したただの作業ログ。 Dockerとは 従来のような物理的な仮想化ではなくコンテナ型仮想化を実現するソフトウェア 例えばLinuxの上に独立したLinuxをシステムを起動できる ハードウェアをシミュレートするのではなくLXCという技術を使ってリソースを隔離する ファイルシステムやプロセス・CPUを共有するので省メモリ・低コストで仮想化できる ざっくりこのような感じだが、パッとこない場合は以下の記事が参考になる。 15分で分かるLXC（Linux Containers）の仕組みと基本的な使い方 クラウド時代のオープンソース実践活用 | 第41回 Linuxコンテナ(LXC)の基礎をまとめ直す Mac OS XにDocker環境を準備する 以下のものをインストールする必要アリ。公式で配布されているDocker Toolboxでも良いが、インストーラ使うとroot領域いじられそうなので、VirtualBox以外はHomebrew経由でインストールする。boot2dockerは使わない。 VirtualBox v5.0.4 docker v1.8.2 docker-machine v0.4.1 $ brew install docker $ brew install docker-machine あとは公式のチュートリアルに沿ってDockerの振る舞いを理解していく。 Docker Machineで仮想マシンを作成する Docker Machineで仮想マシンを立てる。VirtualBoxを使うので、--driverで指定し、マシン名も引数に取る（ここではlocalというマシン名を指定）。作成すると~/.docker/machine/machines/localというフォルダが作成され、マシンの各種設定が保存される。 $ docker-machine create --driver virtualbox local Docker Machineで作成したマシンはlsコマンドでリストアップできる。マシンを削除するにはrmコマンドで。 $ docker-machine ls NAME ACTIVE DRIVER STATE URL SWARM local virtualbox Running tcp://192.168.99.100:2376 $ docker-machine rm local 仮想マシンの各種環境変数 作成したマシンの各種環境変数はenvコマンドで取得可能。出力結果をevalするとそのまま変数を定義できる。 $ docker-machine env local export DOCKER_TLS_VERIFY=&quot;1&quot; export DOCKER_HOST=&quot;tcp://192.168.99.100:2376&quot; export DOCKER_CERT_PATH=&quot;/Users/1000ch/.docker/machine/machines/local&quot; export DOCKER_MACHINE_NAME=&quot;local&quot; # Run this command to configure your shell: # eval &quot;$(docker-machine env local)&quot; hello-worldコンテナを実行してみる 先程のenvコマンドで得られる環境変数をexportした上で、いよいよDockerでコンテナを起動する。今回はhello-worldというコンテナを指定しているが、実行に成功するとハローワールドが表示される。 $ eval &quot;$(docker-machine env local)&quot; $ docker run hello-world ここではhello-worldというコンテナを指定しているが、以下の手順が実施されている。Docketクライアントはコマンドを叩いているターミナルということになる。 DockerクライアントがDockerデーモンに問い合わせる Dockerデーモンがhello-worldイメージをDocker Hubからダウンロードする Docketデーモンがダウンロードしてきたイメージから新たにコンテナを作成する Dockerデーモンがコンテナを標準出力をDocketクライアントに流す nginxコンテナを試してみる バックグラウンドで実行させるために-d（--detach=false）を、ランダムにポートを割り当てるために-P（--publish-all=false）を、明示的に名前を付与すべく--nameも付けて実行する。nginxのプロセスは終了するまで実行され続けるので、-dを付けないとターミナルが持っていかれる。 $ docker run -d -P --name nginx-web nginx 起動中のコンテナ一覧の表示、コンテナの開始と停止と削除 停止にはstopコマンドを、削除にはrmコマンドを使う。それぞれコンテナのID指定するが、コンテナIDは先程のrunコマンドの-dオプションで出力される他、psコマンドの出力結果にも表示される。尚、コンテナに名前が指定されていればコンテナIDではなくコンテナ名を指定しても実行できる。 # 起動中のコンテナ一覧を表示する $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ba377526b912 nginx &quot;nginx -g &#39;daemon off&quot; 26 seconds ago Up 2 seconds 0.0.0.0:32775-&gt;80/tcp, 0.0.0.0:32774-&gt;443/tcp nginx-web # 指定したコンテナを停止する $ docker stop ba377526b912 # 指定したコンテナを開始する $ docker start ba377526b912 # 指定したコンテナを削除する $ docker rm ba377526b912 nginxがホストしているページをブラウザで表示する portコマンドでコンテナに対してマッピングされているポート番号を一覧化できる。先程nginx-webという名前でコンテナを起動したので、それがどのポートに割り当てられているかを確認してみる。 $ docker port nginx-web 443/tcp -&gt; 0.0.0.0:32774 80/tcp -&gt; 0.0.0.0:32775 コンテナの443ポートがローカルホスト（Dockerクライアント）の32774に、コンテナの80ポートがローカルホスト32775にマッピングされているのがわかる。 マシンのIPアドレスを調べる 先程のコンテナのIPアドレスはDockerのホストアドレスではないので、nginxにはアクセスできない。Docker Machineで作成したマシンのIPアドレスをipコマンドを使って調べる。echo $DOCKER_HOSTあたりを実行すると、docker-machine envで出力されたDOCKER_HOSTのIPと一致しているのがわかる。 $ docker-machine ip local 192.168.99.100 $ echo $DOCKER_HOST tcp://192.168.99.100:2376 ブラウザでnginxでホストしているページへアクセスする ここまででnginxが192.168.99.100:32775を待ち構えていることがわかるので、 http://192.168.99.100:32775 にアクセスしてみる。 ローカルのディレクトリをコンテナにマウントする 次に、ローカルのディレクトリをコンテナにマウントしてみる。適当なディレクトリにindex.htmlを配置して、配置したディレクトリをnginxのホストディレクトリにマウントする。それが出来れば先程のURLでindex.htmlの内容が表示されるはずだ。今回はユーザーディレクトリ配下にfooというフォルダを用意し、その中にindex.htmlを配置した。HTMLの中身は何でも良い。 コンテナの再作成からやるので、docker psで起動しているコンテナのコンテナIDを取得し、docker stop [コンテナID]→docker rm [コンテナID]で先程作成したコンテナ（nginx-web）を削除する。削除せずに違う名前でも良いんだけど、テストがてら。 $ docker ps ...">
  

  
    <meta property="og:image" content="https://1000ch.net/favicon.svg">
    <meta name="twitter:image" content="https://1000ch.net/favicon.svg">
  


<meta property="og:type" content="article">
<meta property="og:url" content="https://1000ch.net/posts/2015/docker-introduction.html">
<meta property="og:site_name" content="1000ch.net">
<meta property="og:title" content="Docker事始め作業ログ">

<meta name="twitter:site" content="@1000ch">
<meta name="twitter:url" content="https://1000ch.net/posts/2015/docker-introduction.html">
<meta name="twitter:title" content="Docker事始め作業ログ">

<meta name="google-site-verification" content="BWewniqiBzRmrhpj51eLwug-F4hamFfyznl-ARb-Y4Y">
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon.png">
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="/img/apple-touch-icon.png">
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="/img/apple-touch-icon.png">
<link rel="apple-touch-icon-precomposed" href="/img/apple-touch-icon.png">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-49530352-1', '1000ch.net');
  ga('send', 'pageview');
</script>

  </head>
  <body>
    <div class="Container">
      <header class="Header">
  <h1 class="Header__Title"><a href="/">1000ch.net</a></h1>
  <nav class="Header__Menu">
    <div class="Header__MenuItem">
      <i class="fa fa-rss"></i>
      <a href="/rss.xml">RSS</a>
    </div>
    <div class="Header__MenuItem">
      <i class="fa fa-heart"></i>
      <a href="/activity.html">Activity</a>
    </div>
    <div class="Header__MenuItem">
      <i class="fa fa-facebook-square"></i>
      <a href="https://www.facebook.com/1000ch.net">Facebook</a>
    </div>
  </nav>
</header>

      <div class="Main">
        <span class="Label Label--gray pull-left">2015.09.14</span>

        

<h1 id="docker事始め作業ログ:cdde93ef5507b118dc926636dcdb2b77">Docker事始め作業ログ</h1>

<p>やってみよう系の記事は既にチラホラあるけど、手元の環境に合わせて書き直したただの作業ログ。</p>

<h2 id="docker-https-www-docker-com-とは:cdde93ef5507b118dc926636dcdb2b77"><a href="https://www.docker.com">Docker</a>とは</h2>

<ul>
<li>従来のような物理的な仮想化ではなくコンテナ型仮想化を実現するソフトウェア</li>
<li>例えばLinuxの上に独立したLinuxをシステムを起動できる

<ul>
<li>ハードウェアをシミュレートするのではなくLXCという技術を使ってリソースを隔離する</li>
<li>ファイルシステムやプロセス・CPUを共有するので省メモリ・低コストで仮想化できる</li>
</ul></li>
</ul>

<p>ざっくりこのような感じだが、パッとこない場合は以下の記事が参考になる。</p>

<ul>
<li><a href="http://knowledge.sakura.ad.jp/tech/2108/">15分で分かるLXC（Linux Containers）の仕組みと基本的な使い方</a></li>
<li><a href="http://www.school.ctc-g.co.jp/columns/nakai/nakai41.html">クラウド時代のオープンソース実践活用 | 第41回　Linuxコンテナ(LXC)の基礎をまとめ直す</a></li>
</ul>

<h2 id="mac-os-xにdocker環境を準備する:cdde93ef5507b118dc926636dcdb2b77">Mac OS XにDocker環境を準備する</h2>

<p>以下のものをインストールする必要アリ。公式で配布されている<a href="https://www.docker.com/toolbox">Docker Toolbox</a>でも良いが、インストーラ使うとroot領域いじられそうなので、VirtualBox以外はHomebrew経由でインストールする。boot2dockerは使わない。</p>

<ul>
<li><a href="https://www.virtualbox.org/wiki/Downloads">VirtualBox</a> v5.0.4</li>
<li><a href="https://github.com/docker/docker">docker</a> v1.8.2</li>
<li><a href="https://github.com/docker/machine">docker-machine</a> v0.4.1</li>
</ul>

<pre><code class="language-bash">$ brew install docker
$ brew install docker-machine
</code></pre>

<p>あとは<a href="https://docs.docker.com/installation/mac/">公式のチュートリアル</a>に沿ってDockerの振る舞いを理解していく。</p>

<h2 id="docker-machineで仮想マシンを作成する:cdde93ef5507b118dc926636dcdb2b77">Docker Machineで仮想マシンを作成する</h2>

<p>Docker Machineで仮想マシンを立てる。VirtualBoxを使うので、<code>--driver</code>で指定し、マシン名も引数に取る（ここではlocalというマシン名を指定）。作成すると<code>~/.docker/machine/machines/local</code>というフォルダが作成され、マシンの各種設定が保存される。</p>

<pre><code class="language-bash">$ docker-machine create --driver virtualbox local
</code></pre>

<p>Docker Machineで作成したマシンは<code>ls</code>コマンドでリストアップできる。マシンを削除するには<code>rm</code>コマンドで。</p>

<pre><code class="language-bash">$ docker-machine ls
NAME    ACTIVE   DRIVER       STATE     URL                         SWARM
local            virtualbox   Running   tcp://192.168.99.100:2376

$ docker-machine rm local
</code></pre>

<h3 id="仮想マシンの各種環境変数:cdde93ef5507b118dc926636dcdb2b77">仮想マシンの各種環境変数</h3>

<p>作成したマシンの各種環境変数は<code>env</code>コマンドで取得可能。出力結果を<code>eval</code>するとそのまま変数を定義できる。</p>

<pre><code class="language-bash">$ docker-machine env local
export DOCKER_TLS_VERIFY=&quot;1&quot;
export DOCKER_HOST=&quot;tcp://192.168.99.100:2376&quot;
export DOCKER_CERT_PATH=&quot;/Users/1000ch/.docker/machine/machines/local&quot;
export DOCKER_MACHINE_NAME=&quot;local&quot;
# Run this command to configure your shell:
# eval &quot;$(docker-machine env local)&quot;
</code></pre>

<h3 id="hello-worldコンテナを実行してみる:cdde93ef5507b118dc926636dcdb2b77">hello-worldコンテナを実行してみる</h3>

<p>先程の<code>env</code>コマンドで得られる環境変数を<code>export</code>した上で、いよいよDockerでコンテナを起動する。今回は<code>hello-world</code>というコンテナを指定しているが、実行に成功するとハローワールドが表示される。</p>

<pre><code class="language-bash">$ eval &quot;$(docker-machine env local)&quot;
$ docker run hello-world
</code></pre>

<p>ここでは<code>hello-world</code>というコンテナを指定しているが、以下の手順が実施されている。Docketクライアントはコマンドを叩いているターミナルということになる。</p>

<ol>
<li>DockerクライアントがDockerデーモンに問い合わせる</li>
<li>Dockerデーモンが<code>hello-world</code>イメージをDocker Hubからダウンロードする</li>
<li>Docketデーモンがダウンロードしてきたイメージから新たにコンテナを作成する</li>
<li>Dockerデーモンがコンテナを標準出力をDocketクライアントに流す</li>
</ol>

<h2 id="nginxコンテナを試してみる:cdde93ef5507b118dc926636dcdb2b77">nginxコンテナを試してみる</h2>

<p>バックグラウンドで実行させるために<code>-d</code>（<code>--detach=false</code>）を、ランダムにポートを割り当てるために<code>-P</code>（<code>--publish-all=false</code>）を、明示的に名前を付与すべく<code>--name</code>も付けて実行する。nginxのプロセスは終了するまで実行され続けるので、<code>-d</code>を付けないとターミナルが持っていかれる。</p>

<pre><code class="language-bash">$ docker run -d -P --name nginx-web nginx
</code></pre>

<h3 id="起動中のコンテナ一覧の表示-コンテナの開始と停止と削除:cdde93ef5507b118dc926636dcdb2b77">起動中のコンテナ一覧の表示、コンテナの開始と停止と削除</h3>

<p>停止には<code>stop</code>コマンドを、削除には<code>rm</code>コマンドを使う。それぞれコンテナのID指定するが、コンテナIDは先程の<code>run</code>コマンドの<code>-d</code>オプションで出力される他、<code>ps</code>コマンドの出力結果にも表示される。尚、コンテナに名前が指定されていればコンテナIDではなくコンテナ名を指定しても実行できる。</p>

<pre><code class="language-bash"># 起動中のコンテナ一覧を表示する
$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                           NAMES
ba377526b912        nginx               &quot;nginx -g 'daemon off&quot;   26 seconds ago      Up 2 seconds        0.0.0.0:32775-&gt;80/tcp, 0.0.0.0:32774-&gt;443/tcp   nginx-web

# 指定したコンテナを停止する
$ docker stop ba377526b912

# 指定したコンテナを開始する
$ docker start ba377526b912

# 指定したコンテナを削除する
$ docker rm ba377526b912
</code></pre>

<h3 id="nginxがホストしているページをブラウザで表示する:cdde93ef5507b118dc926636dcdb2b77">nginxがホストしているページをブラウザで表示する</h3>

<p><code>port</code>コマンドでコンテナに対してマッピングされているポート番号を一覧化できる。先程<code>nginx-web</code>という名前でコンテナを起動したので、それがどのポートに割り当てられているかを確認してみる。</p>

<pre><code class="language-bash">$ docker port nginx-web
443/tcp -&gt; 0.0.0.0:32774
80/tcp -&gt; 0.0.0.0:32775
</code></pre>

<p>コンテナの443ポートがローカルホスト（Dockerクライアント）の32774に、コンテナの80ポートがローカルホスト32775にマッピングされているのがわかる。</p>

<h3 id="マシンのipアドレスを調べる:cdde93ef5507b118dc926636dcdb2b77">マシンのIPアドレスを調べる</h3>

<p>先程のコンテナのIPアドレスはDockerのホストアドレスではないので、nginxにはアクセスできない。Docker Machineで作成したマシンのIPアドレスを<code>ip</code>コマンドを使って調べる。<code>echo $DOCKER_HOST</code>あたりを実行すると、<code>docker-machine env</code>で出力された<code>DOCKER_HOST</code>のIPと一致しているのがわかる。</p>

<pre><code class="language-bash">$ docker-machine ip local
192.168.99.100

$ echo $DOCKER_HOST
tcp://192.168.99.100:2376
</code></pre>

<h3 id="ブラウザでnginxでホストしているページへアクセスする:cdde93ef5507b118dc926636dcdb2b77">ブラウザでnginxでホストしているページへアクセスする</h3>

<p>ここまででnginxが<code>192.168.99.100:32775</code>を待ち構えていることがわかるので、 <a href="http://192.168.99.100:32775">http://192.168.99.100:32775</a> にアクセスしてみる。</p>

<h3 id="ローカルのディレクトリをコンテナにマウントする:cdde93ef5507b118dc926636dcdb2b77">ローカルのディレクトリをコンテナにマウントする</h3>

<p>次に、ローカルのディレクトリをコンテナにマウントしてみる。適当なディレクトリに<code>index.html</code>を配置して、配置したディレクトリをnginxのホストディレクトリにマウントする。それが出来れば先程のURLで<code>index.html</code>の内容が表示されるはずだ。今回はユーザーディレクトリ配下に<code>foo</code>というフォルダを用意し、その中に<code>index.html</code>を配置した。HTMLの中身は何でも良い。</p>

<p>コンテナの再作成からやるので、<code>docker ps</code>で起動しているコンテナのコンテナIDを取得し、<code>docker stop [コンテナID]</code>→<code>docker rm [コンテナID]</code>で先程作成したコンテナ（<code>nginx-web</code>）を削除する。削除せずに違う名前でも良いんだけど、テストがてら。</p>

<pre><code class="language-bash">$ docker ps
...

$ docker stop 4bf9cfc2fe49
$ docker rm 4bf9cfc2fe49
</code></pre>

<p>削除したら、以下のコマンドで再度nginxのコンテナを作成する。さっきと違うのは、<code>-v</code>オプションでマウントするディレクトリをしている点。ユーザーディレクトリ配下の<code>foo</code>フォルダをマウントするので<code>$HOME/foo</code>とし、マウント先にはnginxがホストするディレクトリである<code>/usr/share/nginx/html</code>を指定している。</p>

<pre><code class="language-bash">$ docker run -d -P -v $HOME/foo:/usr/share/nginx/html --name nginx-web nginx
</code></pre>

<p>起動したら再び<code>docker port nginx-web</code>で割り当てられたポート番号をチェックし、ブラウザでアクセスしてみる。用意した<code>index.html</code>の中身が表示されればひと通り成功。</p>

<pre><code class="language-bash">$ docker port nginx-web
443/tcp -&gt; 0.0.0.0:32776
80/tcp -&gt; 0.0.0.0:32777
# ブラウザで http://192.168.99.100:32777 にアクセスしてみる
</code></pre>

<h2 id="まとめ:cdde93ef5507b118dc926636dcdb2b77">まとめ</h2>

<ul>
<li>Docker（<code>docker</code>コマンド）でコンテナとそのホストOSを管理する</li>
<li>Docker Machine（<code>docker-machine</code>）でホストOSとなるマシンを管理する</li>
<li>Docker Hubにマシンイメージが集積されている

<ul>
<li>DockerからPullしてコンテナとして利用する</li>
<li>DockerでローカルのイメージをComposeして配布する</li>
</ul></li>
</ul>

        <aside class="Share">
  <div class="Share__Item">
     <a href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2f1000ch.net%2fposts%2f2015%2fdocker-introduction.html" title="Share on Facebook" target="_blank">
       <i class="fa fa-facebook-square"></i>
     </a>
  </div>
  <div class="Share__Item">
    <a href="https://twitter.com/share?url=https%3a%2f%2f1000ch.net%2fposts%2f2015%2fdocker-introduction.html&text=Docker%e4%ba%8b%e5%a7%8b%e3%82%81%e4%bd%9c%e6%a5%ad%e3%83%ad%e3%82%b0" title="Share on Twitter" target="_blank">
      <i class="fa fa-twitter-square"></i>
    </a>
  </div>
  <div class="Share__Item">
    <a href="https://plus.google.com/share?url=https%3a%2f%2f1000ch.net%2fposts%2f2015%2fdocker-introduction.html" title="Share on Google+" target="_blank">
      <i class="fa fa-google-plus-square"></i>
    </a>
  </div>
</aside>

<nav class="Pager">
  
    <div class="Pager__Item Pager__Item--left">
      <i class="fa fa-arrow-left"></i>
      <a href="/posts/2015/frontend-weekly.html">Frontend Weekly購読のススメ</a>
    </div>
  

  
    <div class="Pager__Item Pager__Item--right">
      <a href="/posts/2015/linter-textlint.html">textlintのAtomプラグイン</a>
      <i class="fa fa-arrow-right"></i>
    </div>
  
</nav>

      </div>
      <aside class="Aside">
  <h1>Author</h1>
  <div class="Media">
    <img class="Media__figure" src="/img/1000ch.jpg" alt="1000ch" width="96" height="96">
    <div class="Media__body">
      <div class="Media__title">1000ch <a href="https://twitter.com/1000ch" class="twitter-follow-button" data-show-count="false" data-show-screen-name="false">Follow @1000ch</a></div>
      <div class="Media__description">
        渋谷で働くソフトウェアエンジニア。Web Standards、パフォーマンス、アクセシビリティあたりのキーワードに反応します。
      </div>
    </div>
  </div>
</aside>

      <footer class="Footer">
  <div class="Banner">
    <div class="Banner__Item">
      <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.ja" target="_blank">
        <img src="/img/by-nc-nd.png" alt="CC BY-NC-ND 4.0" width="80" height="28">
      </a>
    </div>
    <div class="Banner__Item">
      <a href="https://cloud.feedly.com/#subscription%2Ffeed%2Fhttp%3A%2F%2Fhttps%3A%2F%2F1000ch.net%2Findex.xml" target="_blank">
        <img src="https://s3.feedly.com/img/follows/feedly-follow-rectangle-flat-medium_2x.png" alt="follow me on feedly" width="71" height="28">
      </a>
    </div>
    <div class="Banner__Item">
      <form action="https://duckduckgo.com/" role="search">
        <input name="sites" type="hidden" value="1000ch.net">
        <input name="q" type="search">
        <input type="submit" value="Search">
      </form>
    </div>
  </div>
</footer>

    </div>
    <script async src="//apis.google.com/js/plusone.js"></script>
<script async src="//platform.twitter.com/widgets.js"></script>
<script async src="//platform.instagram.com/en_US/embeds.js"></script>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
<script src="/js/app.min.js"></script>

  </body>
</html>
